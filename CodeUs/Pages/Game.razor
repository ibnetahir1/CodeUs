@page "/game"
@using CodeUs.Shared.Models;
@using Microsoft.AspNetCore.SignalR.Client;
@inject NavigationManager navigationManager
@inject Shared.StateContainers.PlayInfoContainer playInfoContainer
@inject Shared.StateContainers.IWordsService wordsService
@inject Shared.StateContainers.IRoomsService roomsService

<div class="@_backgroundColorClass">

    <div class="game-state-message">
        <h3>@_gameState</h3>
    </div>

    <div class="voting-modal @_modalDisplay">
        <div class="voting-modal-content">
            <h2>@_playerThatCalledMeeting?.Name called the meeting.</h2>
            <div class="player-list-meeting">
                @foreach (var player in _players!)
                {
                    if(player.IsGuesser == false)
                    {
                        string faction = "";

                        if(player.Name == _currentUserName)
                        {
                            faction = GetFaction(player);
                        }

                        string playerVoted = "player-not-voted";

                        if(player.HasVoted)
                        {
                            playerVoted = "player-voted";
                        }

                        if (!_playerVotingClasses.ContainsKey(player.Name))
                        {
                            _playerVotingClasses.Add(player.Name, "dont-show-voting-items");
                        }

                        string disableVoting = "";

                        if(_players.FirstOrDefault(x => x.Name == _currentUserName!)!.HasVoted)
                        {
                            disableVoting = "disable-voting";
                        }

                        <div class="player-flex">
                            <div class="@playerVoted"></div>
                            <div class="player-name-flex @disableVoting" @onclick="@(() => {
                                                            _playerVotingClasses = _playerVotingClasses.ToDictionary(x => x.Key, x => "dont-show-voting-items");
                                                            _playerVotingClasses[player.Name] = "";
                                                            InvokeAsync(StateHasChanged);
                                                            })">
                                @player.Name: @faction
                            </div>
                            <div class="@_votesDisplay">
                                <b>Votes:</b> 
                                @{
                                    var votes = roomsService.GetRoom(_currentRoomCode!)!.Votes;
                                    var votee = votes.FirstOrDefault(x => x.Key == player.Name);
                                    @if (!votee.Equals(default(KeyValuePair<string, List<string>>)))
                                    {
                                        foreach(var voter in votee.Value)
                                        {
                                            <span style="border-left-style: solid; border-right-style: solid"> @voter </span>
                                        }
                                    }
                                }
                            </div>
                            <div class="check-container @_playerVotingClasses[player.Name]" @onclick="@(() => {
                                                                                            //_playerVotingClasses[player.Name] = "dont-show-voting-items";
                                                                                            //InvokeAsync(StateHasChanged);
                                                                                            SendVote(_currentUserName!, player);
                                                                                            })">
                                <div class="vote-check"></div>
                            </div>
                            <div class="vote-cross @_playerVotingClasses[player.Name]" @onclick="@(() => { _playerVotingClasses[player.Name] = "dont-show-voting-items"; InvokeAsync(StateHasChanged);})"></div>
                        </div>
                    }
                }
            </div>
            <div>
                <button class="skip-vote-button" disabled="@_skipVoteDisabled" @onclick="@(() => SendVote(_currentUserName!, new Player(){Name = "SkipVote"}))">Skip Vote</button>
                <span class="@_votesDisplay">
                    <b>Votes:</b>
                    @{
                        var allVotes = roomsService.GetRoom(_currentRoomCode!)!.Votes;
                        var skipVote = allVotes.FirstOrDefault(x => x.Key == "SkipVote");
                        @if (!skipVote.Equals(default(KeyValuePair<string, List<string>>)))
                        {
                            foreach (var voter in skipVote.Value)
                            {
                                <span style="border-left-style: solid; border-right-style: solid; margin-left: 5px;"> @voter </span>
                            }
                        }
                    }
                </span>
                
            </div>
        </div>
    </div>

    <div class="player-and-words-container">
        <div class="player-list-game">
            <ul class="no-bullets">
                @foreach (var player in _players!)
                {
                    <li>
                        @player.Name: @player.IsGuesser
                    </li>
                }
            </ul>

            <button @onclick="CallMeeting" disabled="@_meetingDisabled">Call Meeting</button>
        </div>

        @if (_currentTurnPlayer != null)
        {
            <div class="word-container">
                @foreach (var word in wordsService.Words)
                {
                    // which faction it belongs to
                    string wordFaction = "";
                    switch (word.Faction)
                    {
                        case Faction.Agent:
                            wordFaction = "word-agent";
                            break;
                        case Faction.Neutral:
                            wordFaction = "word-neutral";
                            break;
                        case Faction.Spy:
                            wordFaction = "word-spy";
                            break;
                    }

                    // only clickable by the guesser when its the guesser's turn
                    string clickable = "";
                    if (_currentTurnPlayer.Name == _currentUserName && _currentTurnPlayer.IsGuesser)
                    {
                        clickable = "guesser-clickable";
                    }
                    else
                    {
                        clickable = "not-clickable";
                    }

                    // the guessed words are not guessable
                    string guessed = "";
                    if (word.IsGuessed)
                    {
                        guessed = "word-guessed";
                    }
                    else
                    {
                        guessed = "word-not-guessed";
                    }

                    // hide faction color from agents if the word is neutral or spy and is not guessed
                    string hideSpyWordsFromAgents = "";
                    Player thisPlayer = roomsService.GetPlayer(_currentUserName!, _currentRoomCode!);
                    if (thisPlayer.Faction == Faction.Agent && (word.Faction == Faction.Neutral || word.Faction == Faction.Spy) && word.IsGuessed == false)
                    {
                        hideSpyWordsFromAgents = "hide-faction-from-agents";
                    }
                    else
                    {
                        hideSpyWordsFromAgents = "dont-hide-faction-from-agents";
                    }

                    // hide faction color for guesser if the word isnt guessed
                    string hideFactionForGuesser = "";
                    if (_guesser?.Name == _currentUserName && word.IsGuessed == false)
                    {
                        hideFactionForGuesser = "hide-faction-for-guesser";
                    }
                    else
                    {
                        hideFactionForGuesser = "dont-hide-faction-for-guesser";
                    }

                    <div class="word @wordFaction @clickable @guessed @hideSpyWordsFromAgents @hideFactionForGuesser" @onclick="@(() => WordGuessed(word))">@word.Value</div>
                }
            </div>
        }

        <div class="game-information">
            <div class="turns-left">
                Turns Left: @_turnsLeft
            </div>
            <div class="game-logs">
                @foreach(var log in roomsService.GetRoom(_currentRoomCode!)!.GameLogs)
                {
                    <div class="log">@log.Log</div>
                }
            </div>
        </div>
    </div>


    @if(_currentTurnPlayer != null)
    {
        if(_gameOver == false)
        {
            // current player who isn't the guesser gets to give clue
            if (_currentTurnPlayer.Name == _currentUserName && _currentTurnPlayer.IsGuesser == false)
            {
                <div class="clue-form-container">
                    <EditForm Model="@_clue" OnValidSubmit="@ClueGiven">
                        <DataAnnotationsValidator />
                        <ValidationSummary />

                        <InputText placeholder="Enter a clue" maxlength="12" @bind-Value="_clue.Hint"></InputText>
                        <InputSelect @bind-Value="_clue.NumberOfWords">
                            @for (int i = 0; i < 10; i++)
                            {
                                <option value="@i">@i</option>
                            }
                        </InputSelect>

                        <button type="submit">Submit</button>
                    </EditForm>
                </div>
            }
            if (_currentTurnPlayer.IsGuesser)
            {
                <div class="clue-container">
                    <span>@_clue.Hint</span> <span>@_clue.NumberOfWords</span>
                    @if (_players.FirstOrDefault(x => x.Name == _currentUserName!)!.IsGuesser)
                    {
                        <span class="skip-turn-container"><button class="skip-turn" @onclick="SkipTurn">Skip Turn</button></span>
                    }
                </div>
            }
        }
        else
        {
            <div class="return-to-lobby-button-container">
                <button class="return-to-lobby" @onclick="ReturnToLobby">Return to Lobby</button>
            </div>
        }
    }

</div>

@code {
    private string? _currentUserName = "";
    private string? _currentRoomCode = "";
    private string _gameState = "";
    private List<string> _gameLogs = new();

    //css classes
    private string _modalDisplay = "modal-not-display";
    private string _votesDisplay = "votes-not-display";
    private string _backgroundColorClass = "";

    //players info
    private List<Player>? _players = new();
    private Player? _guesser;
    private Player? _currentTurnPlayer;
    private Player? _playerThatCalledMeeting;
    private Dictionary<string, string> _playerVotingClasses = new();

    private Clue _clue = new();
    private Word? _lastWordGuessed;
    private bool _gameOver = false;
    private bool _meetingDisabled = false;
    private bool _skipVoteDisabled = false;
    private int _turnsLeft = 0;

    [Inject]
    private HubConnection? HubConnection { get; set; }

    protected override void OnInitialized()
    {
        _currentUserName = playInfoContainer?.Value?.Nickname;
        _currentRoomCode = playInfoContainer?.Value?.RoomCode;
        _players = roomsService.GetRoom(_currentRoomCode!)?.Players;
        _guesser = _players!.FirstOrDefault(x => x.IsGuesser == true);
        _turnsLeft = roomsService.GetRoom(_currentRoomCode!)!.TurnsLeft;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            RegisterEvents();
            if(_players!.FirstOrDefault(x => x.Name == _currentUserName)!.IsHost)
            {
                await SendClue(null);
            }
        }
        _players = roomsService.GetRoom(_currentRoomCode!)?.Players;
        _clue = roomsService.GetRoom(_currentRoomCode!)!.Clue;
    }

    private void RegisterEvents()
    {
        HubConnection!.On("NextTurnAfterClue", NextTurnAfterClue);
        HubConnection!.On<Word>("NextStepAfterGuess", NextStepAfterGuess);
        HubConnection!.On("NextTurnAfterGuesser", NextTurnAfterGuesser);
        HubConnection!.On("GameOverAgentsWin", GameOverAgentsWin);
        HubConnection!.On("GameOverSpyWins", GameOverSpyWins);
        HubConnection!.On("TurnLimitReached", TurnLimitReached);
        HubConnection!.On<Player>("MeetingCalled", MeetingCalled);
        HubConnection!.On("PlayerVoted", PlayerVoted);
        HubConnection!.On<Player>("PlayerVotedOut", PlayerVotedOut);
        HubConnection!.On("NoPlayerVotedOut", NoPlayerVotedOut);
        HubConnection!.On("ContinueGameAfterVoting", ContinueGameAfterVoting);
    }

    /// <summary>
    /// send clue to the hub
    /// </summary>
    /// <returns></returns>
    private async Task SendClue(Clue? clue)
    {
        await HubConnection!.SendAsync("ClueGiven", clue, _currentUserName, _currentRoomCode);
    }

    /// <summary>
    /// send guess to the hub
    /// </summary>
    /// <param name="word"></param>
    /// <returns></returns>
    private async Task SendGuess(Word word)
    {
        await HubConnection!.SendAsync("WordGuessed", word, _currentUserName, _currentRoomCode);
    }

    /// <summary>
    /// from the hub
    /// </summary>
    /// <returns></returns>
    private void NextTurnAfterClue()
    {
        InvokeAsync(StateHasChanged);
        UpdateGameState();
    }

    /// <summary>
    /// from the hub
    /// </summary>
    /// <param name="word"></param>
    /// <returns></returns>
    private async Task NextStepAfterGuess(Word word)
    {
        wordsService.WordGuessed(word);
        _lastWordGuessed = word;

        bool allAgentsGuessed = wordsService.Words.Where(x => x.Faction == Faction.Agent).All(x => x.IsGuessed == true);
        bool allSpiesGuessed = wordsService.Words.Where(x => x.Faction == Faction.Spy).All(x => x.IsGuessed == true);

        if(allAgentsGuessed && _guesser!.Name == _currentUserName)
        {
            await HubConnection!.SendAsync("AllAgentsGuessed", _currentRoomCode);
        }

        else if (allSpiesGuessed && _guesser!.Name == _currentUserName)
        {
            await HubConnection!.SendAsync("AllSpiesGuessed", _currentRoomCode);
        }
        else if ((_clue.GuessesLeft == 0 || word.Faction != Faction.Agent) && _guesser!.Name == _currentUserName)
        {
            await HubConnection!.SendAsync("GuesserTurnDone", _currentRoomCode);
        }
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// from the hub
    /// </summary>
    /// <returns></returns>
    private void NextTurnAfterGuesser()
    {
        _turnsLeft = roomsService.GetRoom(_currentRoomCode!)!.TurnsLeft;
        UpdateGameState();
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void GameOverAgentsWin()
    {
        _gameState = "All agent words guessed! Agents Win!";
        _meetingDisabled = true;
        _gameOver = true;
        _backgroundColorClass = "agents-win-color";
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void GameOverSpyWins()
    {
        _gameState = "All Spy Words Guessed! Spy Wins!";
        _meetingDisabled = true;
        _gameOver = true;
        _backgroundColorClass = "spy-wins-color";
        InvokeAsync(StateHasChanged);
    }

    private void TurnLimitReached()
    {
        _gameState = "No More Turns Left! Spy Wins!";
        _meetingDisabled = true;
        _gameOver = true;
        _backgroundColorClass = "spy-wins-color";
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void MeetingCalled(Player player)
    {
        _modalDisplay = "modal-display";
        _playerThatCalledMeeting = player;
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void PlayerVoted()
    {
        if (_players!.All(x => x.HasVoted) && _players!.FirstOrDefault(x => x.Name == _currentUserName)!.IsHost)
        {
            HubConnection!.SendAsync("AllPlayersVoted", _currentRoomCode);
        }
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void PlayerVotedOut(Player votedOut)
    {
        _votesDisplay = "votes-display";
        InvokeAsync(StateHasChanged);

        var delay = Task.Delay(3000).ContinueWith(_ =>
        {
            if(votedOut.Faction == Faction.Spy)
            {
                _gameState = $"{votedOut.Name} got voted out! Agents Win!";
                _backgroundColorClass = "agents-win-color";
            }
            else
            {
                _gameState = $"{votedOut.Name} got voted out! Spy Wins!";
                _backgroundColorClass = "spy-wins-color";
            }
            CloseModal();
            _gameOver = true;
            InvokeAsync(StateHasChanged);
        });
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void NoPlayerVotedOut()
    {
        _votesDisplay = "votes-display";
        InvokeAsync(StateHasChanged);

        if(_currentUserName == _guesser!.Name)
        {
            var delay = Task.Delay(3000).ContinueWith(_ =>
            {
                HubConnection!.SendAsync("ContinueGameAfterVoting", _currentRoomCode);
            });
        }
    }

    /// <summary>
    /// from the hub
    /// </summary>
    private void ContinueGameAfterVoting()
    {
        _votesDisplay = "votes-not-display";
        _skipVoteDisabled = false;
        CloseModal();
        InvokeAsync(StateHasChanged);
    }

    private void UpdateGameState()
    {
        _currentTurnPlayer = roomsService.GetCurrentTurnPlayer(_currentRoomCode!);

        if (_currentTurnPlayer.IsGuesser && _currentTurnPlayer.Name == _currentUserName)
        {
            _gameState = "Make your guess";
        }
        else if(_currentTurnPlayer.IsGuesser)
        {
            _gameState = $"Waiting for {_currentTurnPlayer.Name} to guess";
        }
        else if (_currentTurnPlayer.Name == _currentUserName)
        {
            _gameState = "Give a clue";
        }
        else
        {
            _gameState = $"Waiting for {_currentTurnPlayer.Name} to give a clue";
        }
        InvokeAsync(StateHasChanged); // the problem COULD be the async (unlikely)
    }

    private async Task ClueGiven()
    {
        //await InvokeAsync(StateHasChanged);
        await SendClue(_clue);
    }

    private async Task WordGuessed(Word word)
    {
        await SendGuess(word);
    }

    private void ReturnToLobby()
    {
        navigationManager.NavigateTo("/lobby");
    }

    private void CallMeeting()
    {
        _meetingDisabled = true;
        Player thisPlayer = _players!.FirstOrDefault(x => x.Name == _currentUserName!)!;
        if (thisPlayer.HasMeeting)
        {
            HubConnection!.SendAsync("CallMeeting", _currentUserName, _currentRoomCode);
        }
        InvokeAsync(StateHasChanged);
    }

    private void CloseModal()
    {
        _modalDisplay = "modal-not-display";
    }

    private string GetFaction(Player player)
    {
        switch (player.Faction)
        {
            case Faction.Agent:
                return "Agent";
            case Faction.Spy:
                return "Spy";
            default:
                return "Neutral";
        }
    }

    private void SendVote(string thisUsername, Player playerVoted)
    {
        _playerVotingClasses = _playerVotingClasses.ToDictionary(x => x.Key, x => "dont-show-voting-items");
        _skipVoteDisabled = true;
        Player thisPlayer = _players!.FirstOrDefault(x => x.Name == _currentUserName!)!;
        if (!thisPlayer.HasVoted)
        {
            HubConnection!.SendAsync("PlayerVoted", thisUsername, playerVoted.Name, _currentRoomCode);
        }
        InvokeAsync(StateHasChanged);
    }

    private async Task SkipTurn()
    {
        await HubConnection!.SendAsync("GuesserTurnDone", _currentRoomCode);
    }
}
